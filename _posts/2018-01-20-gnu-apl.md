---
layout: post
title:  "Small usability updates to GNU APL Emacs mode"
date:   2018-01-20 09:20:00 +0200
categories: apl, emacs
tags: emacs, apl
---
# Small usability updates to GNU APL Emacs mode
1. [Introduction](#intro)
2. [Compiling GNU APL on OSX 10.6](#osx)
3. [Access to build-in help from Emacs](#help)
4. [Customize keyboard layout for Dvorak users](#dvorak)

## Introduction<a name="intro">
In this blog post I'll explain some recent changes I've submitted to GNU APL and GNU APL Emacs mode.

[APL programming language](https://en.wikipedia.org/wiki/APL_(programming_language)) is the language I'm really fascinated by. I've mainly used 2 different implementations: an excellent  implementation (including IDE) from [Dyalog](https://www.dyalog.com/) and the Free Software [GNU APL](https://www.gnu.org/software/apl/), a quality APL2 interpreter implemented by Dr. Jürgen Sauermann.

I've already submitted a couple of changes to GNU APL some time ago, mainly these:
- [patch](http://lists.gnu.org/archive/html/bug-apl/2017-02/msg00209.html) to be able to compile on Sharp Zaurus,
- [additional API](http://lists.gnu.org/archive/html/bug-apl/2017-02/msg00161.html) to be able to change current directory,
- [update](http://lists.gnu.org/archive/html/bug-apl/2017-02/msg00167.html) to be able to use lambdas in user-defined commands
- [documentation update](http://lists.gnu.org/archive/html/bug-apl/2017-04/msg00009.html) converted documentation from the [GNU APL Emacs mode](https://github.com/lokedhs/gnu-apl-mode)(by Elias Mårtenson) to the format which could be used by the GNU APL.

The last patch came from the discussion that documentation on symbols could be a part of GNU APL interpreter itself rather than Emacs mode for it.


## Compiling GNU APL on OSX 10.6<a name="osx">
Recently I've revived my old MacBook late 2006. Since the last OSX available for it is 10.6.8, not a lot of modern software could be installed on it. Hopefully for free and open source software it is at least a chance to compile it on your own.

One of the tools I'm missing on this laptop is Dyalog APL interpreter. It installs but crashes on startup.

Still it is possible to install the GNU APL interpreter on this machine. It is not available in Macports but one can easily checkout the bleeding edge version from the SVN repository:
```
svn co http://svn.savannah.gnu.org/svn/apl/trunk gnu-apl
```

In order to compile I had to modify 2 files since the function **strndup** is not available on this version of OSX 10.6:
```
Index: src/UserPreferences.cc
===================================================================
--- src/UserPreferences.cc	(revision 1043)
+++ src/UserPreferences.cc	(working copy)
@@ -742,7 +742,8 @@
          if (arg_end)   // more arguments
             {
               const int arg_len = arg_end - apl_args;
-              const char * arg = strndup(apl_args, arg_len);
+              char* arg = static_cast<char*>(malloc(arg_len+1));
+              strncpy(arg, apl_args, arg_len);
               expanded_argv.insert_before(index++, arg);
               ++script_argc;
               apl_args += arg_len;
```
and
```
Index: src/libapl.cc
===================================================================
--- src/libapl.cc	(revision 1043)
+++ src/libapl.cc	(working copy)
@@ -388,8 +388,9 @@

 ostringstream out;
   Command::do_APL_command(out, command_ucs);
-
-  return strndup(out.str().data(), out.str().size());
+  char* str = static_cast<char*>(malloc(out.str().size()+1));
+  strncpy(str, out.str().data(), out.str().size());
+  return str;
 }
 //-----------------------------------------------------------------------------
 const unsigned int *
@@ -579,7 +580,9 @@
    value->print(out);

 const string st = out.str();
-   return strndup(st.data(), st.size());
+   char* str = static_cast<char*>(malloc(st.size()+1));
+   strncpy(str, st.data(), st.size());
+   return str;
 }
 //-----------------------------------------------------------------------------
 ostream &
```

## Access to build-in help from Emacs<a name="help">
The idea to move the documentation on symbols from Emacs to GNU APL was implemented only partly. The lacking part was a way to get this documentation back to the Emacs mode from GNU APL. These job requires 2 parts: the native part (on GNU APL side) and elisp side (on Emacs). The native part was to implement a "help" remote command which will return all the documentation (or only information on requested symbol), as it can be seen [here](https://github.com/lokedhs/gnu-apl-mode/pull/30/files).

Since the data flow is from C to Lisp, the natural choice of a data format was [S-expressions](https://en.wikipedia.org/wiki/S-expression), where the list looks like ```(a b c)```, so the data protocol is basically a list of lists containing all the data.

The only "complication" was to prepare a string for sending - surround by quotes, escape quotes and slashes and convert newlines, see the **prepare_string** function:
```c++
// prepare string for sending:
// quotify, escape " and '\', convert newlines
inline std::string prepare_string(const string& string)
{
    std::string result;
    result.reserve(string.length()*1.25);
    result += "\"";
    for (string::size_type i = 0; i < string.length(); ++i) {
        switch (string[i]) {
        case '\n': 
            result += "\\n"; 
            break;
        case '"': // escape double quotes
        case '\\': // escape backslashes
            result += '\\';
            // Fall through.
        default:
            result += string[i];
        }
    }
    result += "\"";
    return result;
}
```
This code is an altered version of some stack overflow answer to the related topic.


On elisp side parsing is rather trivial. As it can be seen in function [gnu-apl--load-help](https://github.com/lokedhs/gnu-apl-mode/pull/26/files#diff-6e0b72fab51043016ef431905a7bc353R465) the main work is done by elisp reader via ```read-from-string``` which naturally parses the S-expressions from the string:
```lisp
(read-from-string "(\"hello\" \"world\" (1 2 3))")

=> (("hello" "world" (1 2 3)) . 25)
```


## Customize keyboard layout for Dvorak users<a name="dvorak">
Next thing in the journey to get convenient GNU APL environment was to possibility to provide [custom keyboard layouts](https://github.com/lokedhs/gnu-apl-mode/pull/25/files) in the GNU APL Emacs mode. Now I was able to define exactly the same keys locations as on my old Macbook with Dvorak layout.

One can just "draw" the layout and set the variable ```gnu-apl-keymap-template``` as in Readme (by the way one can show/hide keyboard in Emacs GNU APL mode with the **C-c C-k** hotkey).

The variable ```gnu-apl--symbols``` has to be modified to provide mapping between physical (or rather "layout".

For Dvorak layout on this keyboard I've designed the following layout
![General layout]({{ "/assets/apl-layout1.png" | absolute_url }})
![With Shift held]({{ "/assets/apl-layout2.png" | absolute_url }})

To do so I've just typed all the characters in (with some modifications of the layout above):

```lisp
;; our layout - see above. basically
;; just typeing all the keys consequently,
;; without and with modifier, row by row
(defvar txm-apl-layout  
      '(("§1234567890[]" .
         "◊¨¯⍒⍋⌽⍉⊖⍟∨∧←→")
        ("±!@#$%^&*(){}" .
         " ⌶⍫      ⍱⍲⍞⍬")
        ("',.pyfgcrl/=" .
         "⍕≤≥⊢↑⊥∇⊣⍴⎕⌿≠")
        ("\"<>PYFGCRL?+" .
         "⍎⍪ ⍣     ⌷⍠⌹")
        ("aoeuidhtns-\\" .
         "⍺○∊↓⍳⌊∆÷⊤⌈×⍀")
        ("AOEUIDHTNS_|" .
         " ⍥⍷ ⍸  ⍨    ")
        ("`;qjkxbmwvz" .
         "⋄⍝⌸∘≡≢⊃∩⍵∪⊂")
        ("~:QJKXBMWVZ" .
         "   ⍤       "))
      "Simple layout description. It is a list of conses, where each cons represents the row on a keyboard. car of the cons are the characters in layout, while cdr of the cons is the APL characters of the same key.")
```

For each row we can convert it to the corresponding row in ```gnu-apl--symbols```:

```lisp
(defun txm-apl-row-to-gnu-apl-desc (row)
  "Convert row from txm-apl-layout into the
list matching gnu-apl--symbols entry"
  (let (result)
    (dotimes (i (length (car row)))
      (let ((found
             (find-if (lambda (x)
                        (string= (second x) (string (elt (cdr row) i))))
                      gnu-apl--symbols-old)))
        (when found
          (push (list
                 (car found) (cadr found) (string (elt (car row) i)))
                result))))
                (nreverse result)))
```                

And finally we need to iterate over all rows and replace existing apl symbols table in GNU APL mode:
```lisp
(defun txm-create-apl--symbols ()
  "Create our layout based on variables txm-apl-layout and
gnu-apl--symbols-old"
  (apply #'append
         (mapcar #'txm-apl-row-to-gnu-apl-desc txm-apl-layout)))

;; finally replace the old GNU APL layout
(setq gnu-apl--symbols (txm-create-apl--symbols))
```



