---
layout: post
title:  "Common Lisp Series package"
date:   2017-12-17 15:13:55 +0200
categories: lisp
---
# Common Lisp Series package

## Introduction
Richard C. Water's [SERIES](http://series.sourceforge.net/) package for Common Lisp introduces the **Series** data type representing lazy sequences and a set of operations on them. The interesting thing about this package is what it allows to substitute many typical loop constructions with more functional approach but without losing on performance.

## Restrictions

The idea is to use CL macrosystem to process the composition of expressions into the call graph and then effectively generate plain loops. Of course this could only be done for a subset of expressions which satisfy the set of limitations on *optimizable expressions*:

1. Expressions must be statically analyzable
1. Expressions must be straight-line computations
1. Procedures called by expressions must be preorder
1. Intermediate values in computations must be sequences
1. Every non-directed data-flow in expression must be on-line

The good thing about these restrictions is what the **SERIES** package during the code walking phase explicitely checks them and issue a warning if some expression could not be optimized. In this case a developer have an opportunity to manually optimize it or restructure to create optimizable expression.

## How to install and use

Just use
```lisp
(ql:quickload "series")
```
to install.

In order to use one could either call the functions directly from the series package or use the function setup all necessary redefinitions for **defun**, **let** etc to try to automatically analyze the code and to setup helper reader macros:
```lisp
(eval-when (:compile-toplevel :execute :load-toplevel)
  (series::install))
```
  
## Performance
  
  In order to test it I decided to compare with a pure functional implementation of some extremely simple function. All comparisons were made with LispWorks 7.0 32bit for Mac OSX. In all cases I compare performance of pure-functional implementation of the algorithm vs implementation with **SERIES**, and providing comparison with the simple *loop* implementation.
  
### Sum of the list

First trivial task is to calculate the sum of the squares of numbers in a list. Pure functional implementation:

```lisp
(defun sum-squares-cl (lst)
  (declare (optimize (safety 0) (speed 3)))
  (reduce #'+ (mapcar #'(lambda (x) (expt x 2)) lst)))
```

The pure functional implementation is a reduce over mapped list with applied square function. Pure *loop*-based implementation looks like this:

```lisp
(defun sum-squares-loop2 (lst)
  (declare (optimize (safety 0) (speed 3)))
  (loop for x in lst
        summing (expt x 2)))
```

Here we use **summing** facility of the *loop* macro, avoiding introducing accumulator variable.

The implementation using **SERIES** package:

```lisp
(defun sum-squares-series2 (lst)
  (declare (optimize (safety 0) (speed 3)))
    (collect-sum (mapping ((x (scan lst))) (expt x 2))))
```

Here the conversion of the list ```lst``` into the series happens with function ```scan```.
Series ```mapping``` macro defines a list of ```let``` like bindings as a first argument and a body of the function as a second.
```collect-sum``` allows to collect resuls. More generic implementation below:

```lisp
(defun sum-squares-series1 (lst)
  (declare (optimize (safety 0) (speed 3)))
  (collect-fn 'integer (lambda () 0) #'+
              (mapping ((x (scan lst)))
                         (expt x 2))))
```

More generic version uses the ```collect-fn``` function - the building block for accumulation functions using *series* expressions.

Simple comparison (using alexandria's ```iota``` function which generates a list of integers up to its argument) gives the following results:
```
SERIES-TEST 350 > (time (loop for i below 4000 do (sum-squares-cl (iota i))))
Timing the evaluation of (LOOP FOR I BELOW 4000 DO (SUM-SQUARES-CL (IOTA I)))

User time    =        2.622
System time  =        0.005
Elapsed time =        2.606
Allocation   = 251432784 bytes
2 Page faults
Calls to %EVAL    68022
NIL

SERIES-TEST 351 > (time (loop for i below 4000 do (sum-squares-loop1 (iota i))))
Timing the evaluation of (LOOP FOR I BELOW 4000 DO (SUM-SQUARES-LOOP1 (IOTA I)))

User time    =        1.528
System time  =        0.001
Elapsed time =        1.510
Allocation   = 155452628 bytes
0 Page faults
Calls to %EVAL    68022
NIL

SERIES-TEST 352 > (time (loop for i below 4000 do (sum-squares-series1 (iota i))))
Timing the evaluation of (LOOP FOR I BELOW 4000 DO (SUM-SQUARES-SERIES1 (IOTA I)))

User time    =        1.450
System time  =        0.001
Elapsed time =        1.432
Allocation   = 155458444 bytes
1 Page faults
Calls to %EVAL    68022
NIL

SERIES-TEST 353 > (time (loop for i below 4000 do (sum-squares-series2 (iota i))))
Timing the evaluation of (LOOP FOR I BELOW 4000 DO (SUM-SQUARES-SERIES2 (IOTA I)))

User time    =        1.530
System time  =        0.003
Elapsed time =        1.512
Allocation   = 155467608 bytes
0 Page faults
Calls to %EVAL    68022
NIL

```

From this results one can see what the pure functional implementation is slowest, while using both versions of the *series* function gives the same performance as the version with ```loop``` macro.


### Sum of the list with conditions.


